#!/bin/bash
#: Title		:encryption_services
#: Date			:2019-07-13
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:script provides encryption services both to other scripts  
#: Description	:and to the command-line user.  
#: Description	:to encrypt on or more files.
#: Description	:to backup configurations, revocation certs and keys in appropriate ways
#: Description	:integrate with existing system of backup, synchronisation and encryption 
#: Description	:ssh into remotes to backup their keys too
#: Options		:
##
echo "USAGE: $(basename $0) <file paths>" # zero or more strings (representing fullpaths to files)
## at command line:~# 
##
#######################################################################

## REMEMBER TO CREATE A GOOD SYSTEM OF VARIABLE SEMANTICS BEFORE
# STARTING TO ASSIGN NAMES. AVOID ON-THE-FLY NAMING. 

#######################################################################

# if we're located outide an executable PATH directory, (eg in a git tracked project directory)
# soft link from PATH directory located namesake
# ln -s TARGET LINK

#######################################################################

# the parent process - so we set any environment variables here.
## AND REMEMBER TO SANITISE CODE

#######################################################################


## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_REQUIRED_PROGRAM_NOT_FOUND=21
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_REQUIRED_PROGRAM_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################


# GLOBAL VARIABLE DECLARATIONS:

declare -a incoming_array=()
incoming_string=""

plaintext_file_fullpath=""
plaintext_dir_fullpath=""
abs_filepath_regex='^(/{1}[A-Za-z0-9\._-~]+)+$' # absolute file path, ASSUMING NOT HIDDEN FILE, ...
all_filepath_regex='^(/?[A-Za-z0-9\._-~]+)+$' # both relative and absolute file path


echo "	==================================================================="
echo "	||                Welcome to ENCRYPTION SERVICES                   ||  author: adebayo10k"  
echo "	==================================================================="
echo
echo " Type q to quit."
echo && #sleep 2

###############################################################################################


# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF

# NOTE: if soft-linked from an executables PATH directory, this gives the path to the link
echo "The absolute path to this script is: $0"

## TODO: UNLESS SCRIPT 'SOMEHOW' SITS IN THE ROOT DIRECTORY, IN WHICH CASE WE'D JUST REMOVE "$(basename $0)"
## remove from end of full path to script: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"  
echo "Script root directory set to: $script_root_dir"
export script_root_dir


echo "ON ENTRY, script_root_dir WAS SET TO: $script_root_dir"
echo "YOUR CURRENT SHELL LEVEL IS: $SHLVL"

read





###############################################################################################
###############################################################################################
###############################################################################################
# creates a command string for the gpg pubic key encryption of the plaintext file
# shows user the command it wants to execute and await user confirmation 
# executes the command
function create_and_execute_file_encryption_command
{
	service_option="NULL"
	
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "user has selected option: $service_option"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}
###############################################################################################
# list the keys available on the system
# get the users' gpg user-id 
# test that valid, ultimate trust fingerprint exists for that user-id
function check_gpg_user_keys
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	userid=""

	# issue gpg commands to list keys for now... just as a prompt of user-id details
	bash -c "gpg --list-key"
	bash -c "gpg --list-secret-keys"

	# get the users' gpg UID from terminal
	echo "Please enter your user-id (example: smoothcoder@sharkpool.org)"

	read userid

	# now check for a key-pair fingerprint. TODO: if not found, user should have the opportunity to try again
	# TODO: THIS IS NOT THE RIGHT TEST, FIND SOMETHING BETTER LATER
	bash -c "gpg --fingerprint "$userid" 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "KEY-PAIR FINGERPRINT IDENTIFIED FOR USER-ID OK"
	else
		echo "FAILED TO FIND THE KEY-PAIR FINGERPRINT FOR THAT USER-ID"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi



	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################

# check that the OpenPGP tool gpg is installed on the system
#  
function check_encryption_platform
{
		
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	bash -c "which gpg 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "OpenPGP PROGRAM INSTALLED ON THIS SYSTEM OK"
	else
		echo "FAILED TO FIND THE REQUIRED OpenPGP PROGRAM"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################

###############################################################################################

# firstly, we test that the parameter we got is of the correct form for an absolute file path 
# 
# 
function test_file_path_valid_form
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	
	echo "test_file_fullpath is set to: $test_file_fullpath"
	#echo "test_dir_fullpath is set to: $test_dir_fullpath"

	if [[ $test_file_fullpath =~ $abs_filepath_regex ]]
	then
		echo "THE FORM OF THE INCOMING PARAMETER IS THEREFORE OF A VALID ABSOLUTE FILE PATH"
		# from now on, we can talk about a plaintext file path...
		plaintext_file_fullpath="$test_file_fullpath"
		echo "The full path to the plaintext file is: $plaintext_file_fullpath"

		## ASSUMING THE FILE IS NOT 'SOMEHOW' SITTING IN THE ROOT DIRECTORY
		plaintext_dir_fullpath=${plaintext_file_fullpath%/*}
		#plaintext_dir_fullpath=$(echo $plaintext_file_fullpath | sed 's/\/[^\/]*$//') ## also works
		echo "The full path to the plaintext file holding directory is: $plaintext_dir_fullpath"
	else
		echo "AN INCOMING PARAMETER WAS SET, BUT WAS NOT A MATCH FOR OUR KNOWN PATH FORM REGEX "$abs_filepath_regex"" && sleep 1 && echo
		echo "Exiting..."
		exit $E_UNEXPECTED_ARG_VALUE
	fi 


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}



###############################################################################################
# need to test for read access to file 
# need to test for access to the file holding directory
# 
function test_file_path_access
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	test_dir_fullpath=$2

	echo "test_file_fullpath is set to: $test_file_fullpath"
	echo "test_dir_fullpath is set to: $test_dir_fullpath"



	if [ -d "$test_dir_fullpath" ] && cd "$test_dir_fullpath" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir_fullpath" found and accessed ok" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi

	# test for expected file type (regular) and read permission
	if [ -f "$test_file_fullpath" ] && [ -r "$test_file_fullpath" ]
	then
		# plaintext file found and accessible
		echo "Plaintext file found to be readable" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
#########################################################################################################
## SET GLOBAL VARIABLES REGARDING SPECIFIC SERVICE
function dummy
{
	service_option="$1"
	
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "user has selected option: $service_option"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################
function get_required_service_type
{
##
	echo
	echo ">>>   Which encryption type services do you require...?   :::"
	echo
	### 
	echo ">>>   1 = gpg encryption of one or more plaintext files"
	## 
	echo ">>>   2 = gpg decryption of one or more encrypted files"
	echo ">>>   3 = backup of keys and certs to synch'd location"
	echo

	read service_option

	dummy $service_option

}

###############################################################################################
###############################################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'MAIN SECTION'"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

# #########

# NEW STRATEGY:
# ENCRYPTION SERVICES WILL NOW:
#ESTABLISH WHAT SERVICES ARE REQUIRED
#ESTABLISH WHAT TYPE OF ARGUMENTS IT HAS BEEN CALLED WITH AND HOW MANY
#DO INPUT VALIDATION OF THOSE ARGUMENTS
#... IT WILL THEN CALL THE APPROPRIATE SPECIALISED SCRIPT FOR THE JOB

# 0. FIND OUT WHICH SERVICE IS REQUIRED

get_required_service_type

# 1. DETERMINE HOW MANY ARGUMENTS HAVE BEEN PASSED INTO THIS SCRIPT
number_of_incoming_params=$#

echo "Number of arguments passed in = $number_of_incoming_params"

# 2. DETERMINE DATA TYPE | DO A FILE PATH VALIDATION TEST | 

# put the incoming data into an array 
if [ $number_of_incoming_params -gt 0 ]
then
	incoming_array=( "$@" )

	# temporary debug check
	for incoming_string in "${incoming_array[@]}"
	do
		echo "$incoming_string"
	done
fi


# 3. TEST THAT INCOMING STRINGS ARE ALL VALID AND ACCESSIBLE FILE PATHS

for incoming_string in "${incoming_array[@]}"
do
	echo "incoming string is now: $incoming_string"
	test_file_path_valid_form "$incoming_string"
	test_file_path_access "$plaintext_file_fullpath" "$plaintext_dir_fullpath"

done

# 4. CHECK THE STATE OF THE ENCRYPTION ENVIRONMENT

# 
check_encryption_platform
# 
check_gpg_user_keys # from user
# 
create_and_execute_file_encryption_command

# 5. BASED ON PREVIOUSLY SELECTED SERVICE OPTION, CALL AN APPROPRIATE SCRIPT



# 6. ON RETURN OF CONTROL, CHECK FOR DESIRED POSTCONDITIONS


exit 0









incoming_parameter=${1:-"not_yet_set"} ## whether this script run directly from command-line or called by another script
# might also be useful to validate that no parameters were given from the command line.


#primerArray=("${!1}")

#for generated_hash in "${primerArray[@]}"; do


# tests whether parameter in of type array, if true returns 0, else returns 1
# declare -a ## returns list of all the current array variables
# grepping with our array works, but not 100% clear on mechanism...	
# TODO: TURN THIS INTO A GENERAL PURPOSE type_array_test FUNCTION IF IT IS NEEDED AGAIN
declare -a | grep "${incoming_parameter}" 2> /dev/null ##
if [ $? -eq 0 ]
then
	echo "THE INCOMING PARAMETER WAS OF TYPE ARRAY"
	incoming_array=("${incoming_parameter[@]}")
else
	echo "The incoming parameter was NOT of type ARRAY"
fi

echo ${incoming_parameter[@]}

# test whether incoming parameter is of type string

exit 0




# if ... don't forget to unset when returning to calling program),



## USE CASE - CALLED BY audit_list_maker TO GPG ENCRYPT A SINGLE FILE

# FOR ENCRYPTION OF A SINGLE FILE, ALL es EVER NEEDS TO BE PASSED AS A PARAMETER IS THE ABSOLUTE PATH FILENAME OF THE 
# PLAINTEXT FILE. IT CAN GET EVERYTHING ELSE IT NEEDS EITHER FROM CONFIGURATION FILE DEFAULTS, OR FROM THE USER.
#

# decides whether being called directly or by another script

# takes in, validates and assigns the plaintext filename parameter

# tests its environment - config files, `which gpg`, public key-pair pre-generated...


# gets  and validates any unknown required parameters from the user - sender, recipient UID (based on `hostname`) \
#  if using public key encryption - ANY DEFAULTS FOR THIS COULD BE IN A CONFIGURATION FILE FOR THIS PROGRAM
	# - cryptographic system to be used (whether public key or symmetric key crypto)
	# - the output format whether the binary default for gpg or ascii armoured
	# - the desired output filename for the encrypted file (full path): [DEFAULT = SAME AS INPUT WITH .asc|.pgp]

# if all good, es shows user the command it wants to execute
# $ gpg --armor --output "$plaintext_file_fullpath.asc" --local-user <uid> recipient <uid> --encrypt "$plaintext_file_fullpath"

# if user give ok, es executes the command(s)

# es tests resulting postconditions#

# es reports success to user and returns control




#ssh hostname ## this command likely to be read in from file

## definitely control the hosts on which this program can run
#
# hostname will determine which ssh code runs
#
# these files need to be backed up and encrypted:
#public keyrings such as:
#~/.gnupg/pubring.gpg 
#~/.gnupg/pubring.kbx
#
#these revocation certs need to be CIA stored, so backup and encryption as well as on separate media
#~/.gnupg/opengpg_revocs.d/
#
#integration with existing system may look like:
#- an option to run this script post-shred an pre-mutables synchronisation


for ((index=0; index<$number_of_incoming_params; index++));
	do	
		position=$((index + 1))
		echo "position is set to: $position"
		incoming_array[$index]=${postition}
	done
	#for ((i=0; i<${#b64_index_numbers[@]}; i++));