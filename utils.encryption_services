#!/bin/bash
#: Title		:encryption_services
#: Date			:2019-07-13
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:script provides encryption services both to other scripts  
#: Description	:and to the command-line user.  
#: Description	:to encrypt one or more files.
#: Description	:to backup configurations, revocation certs and keys in appropriate ways
#: Description	:integrate with existing system of backup, synchronisation and encryption 
#: Description	:ssh into remotes to backup their keys too
#: Options		:
##
echo "USAGE: $(basename $0) <file paths>" # zero or more strings (representing fullpaths to files)
## at command line:~# 
##
#######################################################################

## REMEMBER TO CREATE A GOOD SYSTEM OF VARIABLE SEMANTICS BEFORE
# STARTING TO ASSIGN NAMES. AVOID ON-THE-FLY NAMING. 

#######################################################################

# if we're located outide an executable PATH directory, (eg in a git tracked project directory)
# soft link from PATH directory located namesake
# ln -s TARGET LINK

#######################################################################

# the parent process - so we set any environment variables here.
## AND REMEMBER TO SANITISE CODE

#######################################################################


## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_REQUIRED_PROGRAM_NOT_FOUND=21
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_REQUIRED_PROGRAM_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################


# GLOBAL VARIABLE DECLARATIONS:

config_file_fullpath= # a full path to a file

service_index= # service number of selected service

declare -a incoming_array=()
#incoming_string=""

encryption_system= # public_key | symmetric_key
output_file_format= # ascii | binary
sender_uid=""
recipient_uid=""
declare -a recipient_uid_list=()

generic_command=""
file_specific_command=""

gpg_command='gpg'
armor_option='--armor'
output_option='--output'
#ascii_file_extension='.asc' #default
#binary_file_extension='.gpg'
output_file_extension= # .asc | .gpg
sender_option='--local-user'
recipient_option='--recipient'
#public_key_encrypt_option='--encrypt'
#symmetric_encrypt_option='--symmetric'
encryption_system_option= # --encrypt | --symmetric
file_path_placeholder='<filepath_placeholder>'

plaintext_file_fullpath=""
plaintext_dir_fullpath=""
abs_filepath_regex='^(/{1}[A-Za-z0-9\._-~]+)+$' # absolute file path, ASSUMING NOT HIDDEN FILE, ...
all_filepath_regex='^(/?[A-Za-z0-9\._-~]+)+$' # both relative and absolute file path

synchronised_location=


echo "	==================================================================="
echo "	||                Welcome to ENCRYPTION SERVICES                   ||  author: adebayo10k"  
echo "	==================================================================="
echo
echo " Type q to quit."
echo && #sleep 2

###############################################################################################


# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF

# NOTE: if soft-linked from an executables PATH directory, this gives the path to the link
echo "The absolute path to this script is: $0"

## TODO: UNLESS SCRIPT 'SOMEHOW' SITS IN THE ROOT DIRECTORY, IN WHICH CASE WE'D JUST REMOVE "$(basename $0)"
## remove from end of full path to script: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"  
echo "Script root directory set to: $script_root_dir"
export script_root_dir


echo "ON ENTRY, script_root_dir WAS SET TO: $script_root_dir"
echo "YOUR CURRENT SHELL LEVEL IS: $SHLVL"

read

#######################################################################
###############################################################################################
# 
# 
function generate_gpg_key_pair
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	# :
	gpg --full-gen-key	

	# copy public keyring (each format) to the defined synchronised location 


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
###############################################################################################
# test for removal of plaintext file(s)
# 
function verify_file_shred_results
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	# :
	for valid_path in "${incoming_array[@]}"
	do
		if [ -f "${valid_path}" ]
		then
			# failure of shred
			echo "FAILED TO CONFIRM THE SHRED REMOVAL OF FILE:"
			echo "${valid_path}" && echo
		else
			# success of shred
			echo "SUCCESSFUL SHRED REMOVAL OF FILE:"
			echo "${valid_path}" && echo

		fi
	done


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
# standard procedure once encrypted versions exits: remove the plaintext versions!
function shred_plaintext_files
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	echo "Ok to shred the following plaintext file(s)?..." && echo

	# list the encrypted files:
	for valid_path in "${incoming_array[@]}"
	do
		echo "${valid_path}"	
	done

	# for now, confirmation by pressing enter
	read

	# shred the plaintext file and verify its' removal
	for valid_path in "${incoming_array[@]}"
	do
		sudo shred -n 1 -ufv "${valid_path}"	
	done

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
# test for encrypted file type
# test for read access to file 
# 
function verify_file_encryption_results
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	valid_path="$1"


	result=$(file "${valid_path}$output_file_extension" | grep 'PGP') # &2>/dev/null)

	if [ $? -eq 0 ] && [ "$encryption_system" == "public_key" ]
	#if [ $result -eq 0 ]
	then
		echo "PUBLIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
		echo "${valid_path}$output_file_extension"
	elif [ $? -eq 0 ] && [ "$encryption_system" == "symmetric_key" ]
	then
		echo "SYMMETRIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
		echo "${valid_path}$output_file_extension"
	else
		return 1 ## unexpected file type
	fi

	
	# test encrypted file for expected file type (regular) and read permission
	if [ -f "${valid_path}$output_file_extension" ]  && [ -r "${valid_path}$output_file_extension" ]
	then
		# encrypted file found and accessible
		echo "Encrypted file found to be readable" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Returning from function ${FUNCNAME[0]} in script $(basename $0)"
		return $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

	return 0
}

###############################################################################################
# the absolute path to the plaintext file is passed in
#
function execute_file_specific_encryption_command
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	valid_path="$1"

	# using [,] delimiter to avoid interference with file path [/]
	file_specific_command=$(echo "$generic_command" | sed 's,'$file_path_placeholder','$valid_path',' | sed 's,'$file_path_placeholder','$valid_path',')

	echo "$file_specific_command"

	# get user confirmation before executing file_specific_command
	# [call a function for this, which can abort the whole encryption process if there's a problem at this point]
	echo && echo "Command look OK?"
	read	# just pause here for now

	# execute file_specific_command if return code from user confirmation = 0
	# execute [here] using bash -c ...
	bash -c "$file_specific_command"


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
# this function called if encryption_system="symmetric"
function create_generic_symmetric_key_encryption_command_string
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "OK, WE'RE HERE, READY TO BUILD THAT COMMAND STRING"

# $ gpg --armor --output "$plaintext_file_fullpath.asc" --symmetric "$plaintext_file_fullpath"

	generic_command=

	generic_command+="${gpg_command} "

	if [ $output_file_format == "ascii" ]
	then
		generic_command+="${armor_option} "
		generic_command+="${output_option} ${file_path_placeholder}"
		generic_command+="${output_file_extension} "
	fi

	generic_command+="${encryption_system_option} ${file_path_placeholder}"


	echo "$generic_command"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}
###############################################################################################
# this function called if encryption_system="public_key"
function create_generic_pub_key_encryption_command_string
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "OK, WE'RE HERE, READY TO BUILD THAT COMMAND STRING"

# $ gpg --armor --output "$plaintext_file_fullpath.asc" --local-user <uid> --recipient <uid> --encrypt "$plaintext_file_fullpath"

	generic_command=

	generic_command+="${gpg_command} "

	if [ $output_file_format == "ascii" ]
	then
		generic_command+="${armor_option} "
		generic_command+="${output_option} ${file_path_placeholder}"
		generic_command+="${output_file_extension} "
	fi

	generic_command+="${sender_option} "
	generic_command+="${sender_uid} "

	for recipient in ${recipient_uid_list[@]}
	do
		generic_command+="${recipient_option} ${recipient} "
	done

	generic_command+="${encryption_system_option} ${file_path_placeholder}"

	echo "$generic_command"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}


###############################################################################################

function get_recipient_uid
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	while true
	do

		echo "Enter the user-id of a RECIPIENT || Type exit"
		read uid

		# validate recipient_uid HERE

		recipient_uid="$uid"
		echo "One recipients user-id is now set to the value: $recipient_uid" && echo
		recipient_uid_list+=( "${recipient_uid}" )
		
		echo "Any more recipients (whose public keys we hold) [y/n]?"
		read more_recipients_answer


		case $more_recipients_answer in
		[yY])	echo "OK, another recipient requested...." && echo
				;;
		[nN])	echo "OK, no more recipients needed...." && echo
				break
				;;
		*)		echo "Entered the FAILSAFE BRANCH...." && echo
				echo "Continuing with while loop, as if (y) response...." && echo 
				;;
		esac
	done


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
# 
function get_sender_uid
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "Enter the user-id of the SENDER || Type q to exit"
	read uid

	# TODO: validate sender_uid HERE. IT MUST CORRESPOND TO ONE OF THE PRIVATE KEYS.
	# FAIL AND REPEAT REQUEST IF THIS IS NOT THE CASE

	sender_uid="$uid"
	echo "sender user-id is now set to the value: $sender_uid"



	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
#
function set_defaults
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	encryption_system="public_key" #default
	output_file_format="ascii" #default

	if [ $encryption_system == "public_key" ]
	then
		encryption_system_option='--encrypt'
	elif [ $encryption_system == "symmetric_key" ]
	then
		encryption_system_option='--symmetric'
	else
		echo "FAILSAFE BRANCH ENTERED"
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED
	fi

	if [ $output_file_format == "ascii" ]
	then
		output_file_extension=".asc" #default
	elif [ $output_file_format == "binary" ]
	then
		output_file_extension=".gpg"
	else
		echo "FAILSAFE BRANCH ENTERED"
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED
	fi	


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
###############################################################################################
###############################################################################################
# 
function get_file_encryption_config_mode
{
		echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	## reset variables:
	mode_answer=""
	
	echo ">>>   Use defaults or configure parameters...?   :::"
	echo
	echo "Defaults mode = 2"
	echo "Config mode = 9"
	echo

	read mode_answer
	case $mode_answer in 
		[2])	set_defaults ## set all the defaults by importing them from a configuration file
								# or for now, just assigning the values
				echo "DEFAULT VALUES FOR COMMAND GENERATION HAVE NOW BEEN SET"
				#
				return 2
					;;
		[9]) 	echo "IN FUTURE, WE'LL GET USER PROVIDED CONFIGURATION PARAMETERS."
				echo "... BUT FOR NOW, ONLY DEFAULTS MODE IS AVAILABLE."
				get_file_encryption_config_mode
				# return 9
					;;
		*) 		echo "Just one of two numbers... a [2] or a [9]..." && sleep 1
				get_file_encryption_config_mode
					;;
	esac 

	echo
	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
# list the keys available on the system
# get the users' gpg user-id 
# test that valid, ultimate trust fingerprint exists for that user-id
function check_gpg_user_keys
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	userid=""

	# issue gpg commands to list keys for now... just as a prompt of user-id details
	bash -c "gpg --list-key"
	bash -c "gpg --list-secret-keys"

	# get the users' gpg UID from terminal
	echo "Enter your user-id (example: order@entropism.org)"

	read userid

	# now check for a key-pair fingerprint. TODO: if not found, user should have the opportunity to try again
	# TODO: THIS IS NOT THE RIGHT TEST, FIND SOMETHING BETTER LATER
	bash -c "gpg --fingerprint "$userid" 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "KEY-PAIR FINGERPRINT IDENTIFIED FOR USER-ID OK"
	else
		echo "FAILED TO FIND THE KEY-PAIR FINGERPRINT FOR THAT USER-ID"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

########################################################################################## 
###############################################################################################
# CODE TO ENCRYPT A SET OF FILES:
###############################################################################################

function gpg_file_encryption_service
{

	# 5. BASED ON PREVIOUSLY SELECTED SERVICE OPTION, CALL AN APPROPRIATE SCRIPT (although we'll do stuff here for now)

	# sets the generic_command global
	#create a generic file encryption command string for either public key or symmetric key encryption:

	# 
	check_gpg_user_keys # from user

	get_file_encryption_config_mode

	if [ $encryption_system = "public_key" ]
	then
		echo "encrytion_system is set to public-key, so we now need to request sender and recipient uids"

		get_sender_uid
		echo "sender user-id is now set to the value: $sender_uid"

		get_recipient_uid
		for recipient in ${recipient_uid_list[@]}
		do
			echo "From our array, a recipient is: ${recipient}"
		done

		create_generic_pub_key_encryption_command_string ## make this a public key specific one

	else # encryption_system must be symmetric [make this into an elif]
		create_generic_symmetric_key_encryption_command_string ##  make this a symmetric key specific one
	fi

	#create, then execute each file specific encryption command, then shred plaintext file:
	for valid_path in "${incoming_array[@]}"
	do
		echo "about to execute on file: $valid_path"
		execute_file_specific_encryption_command "$valid_path" #

		# check that expected output file now exists, is accessible and has expected encypted file properties
		verify_file_encryption_results "${valid_path}"
		if [ $? -ne 0 ]
		then
			echo "FAILURE REPORT...ON STATE..."
			exit 1
		fi	
	done

	# 6. SHRED THE PLAINTEXT FILES, NOW THAT ENCRYPTED VERSION HAVE BEEN MADE

	# first checking that the shred program is installed
	which shred #&> /dev/null
	if [ $? -eq 0 ]
	then
		shred_plaintext_files
		verify_file_shred_results		
	else
		echo "FAILED TO FIND THE SHRED PROGRAM ON THIS SYSTEM, SO SKIPPED SHREDDING OF ORIGINAL PLAINTEXT FILES"
	fi	

}


###############################################################################################
###############################################################################################

# check that the OpenPGP tool gpg is installed on the system
#  
function check_encryption_platform
{
		
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	bash -c "which gpg 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "OpenPGP PROGRAM INSTALLED ON THIS SYSTEM OK"
	else
		echo "FAILED TO FIND THE REQUIRED OpenPGP PROGRAM"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################

###############################################################################################

# firstly, we test that the parameter we got is of the correct form for an absolute file path 
# if this test fails, there's no point doing anything further
# 
function test_file_path_valid_form
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	test_result=
	test_file_fullpath=$1
	
	echo "test_file_fullpath is set to: $test_file_fullpath"
	#echo "test_dir_fullpath is set to: $test_dir_fullpath"

	if [[ $test_file_fullpath =~ $abs_filepath_regex ]]
	then
		echo "THE FORM OF THE INCOMING PARAMETER IS OF A VALID ABSOLUTE FILE PATH"
		test_result=0
	else
		echo "AN INCOMING PARAMETER WAS SET, BUT WAS NOT A MATCH FOR OUR KNOWN PATH FORM REGEX "$abs_filepath_regex"" && sleep 1 && echo
		echo "Returning with a non-zero test result..."
		test_result=1
		return $E_UNEXPECTED_ARG_VALUE
	fi 


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

	return "$test_result"
}

###############################################################################################
# need to test for read access to file 
# need to test for access to the file holding directory
# 
function test_file_path_access
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	test_result=
	test_file_fullpath=$1
	test_dir_fullpath=$2

	echo "test_file_fullpath is set to: $test_file_fullpath"
	echo "test_dir_fullpath is set to: $test_dir_fullpath"


		# && if #2 is set
	if [ -d "$test_dir_fullpath" ] && cd "$test_dir_fullpath" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir_fullpath" found and accessed ok" && echo
		test_result=0
	else
		# -> return due to failure of any of the above tests:
		test_result=1
		echo "Returning from function \"${FUNCNAME[0]}\" with test result code: $E_REQUIRED_FILE_NOT_FOUND"
		return $E_REQUIRED_FILE_NOT_FOUND
	fi

	# test for expected file type (regular) and read permission
	if [ -f "$test_file_fullpath" ] && [ -r "$test_file_fullpath" ]
	then
		# test file found and accessible
		echo "Test file found to be readable" && echo
		test_result=0
	else
		# -> return due to failure of any of the above tests:
		test_result=1
		echo "Returning from function \"${FUNCNAME[0]}\" with test result code: $E_REQUIRED_FILE_NOT_FOUND"
		return $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

	return "$test_result"
}

###############################################################################################
#########################################################################################################
## SET GLOBAL VARIABLE service_index WRT A SPECIFIC SERVICE
# CALL THE FUNCTIONS AND SCRIPTS THAT COMBINE TO PROVIDE THE REQUESTED SERVICE
function call_service
{
	service_option="$1"
	
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "user has selected option: $service_option"

case $service_option in
	1)		# gpg file encryption service:
			service_index=1
			echo "YOU REQUESTED THE GPG FILE ENCRYPTION SERVICE"

			# NOW WE MUST CHECK FOR PRE-REQUISITES:
			# does incoming_array have one or more elements?
			# ...
			if [ ${#incoming_array[@]} -gt 0 ]
			then
				gpg_file_encryption_service
			else
				echo "TRIED TO DO FILE ENCRYPTION WITHOUT ANY INCOMING FILEPATH PARAMETERS"	
				exit "$E_INCORRECT_NUMBER_OF_ARGS"
			fi
			;;

	2)		# gpg decryption ... for now, return to get_required_service_type and go loopy:
			service_index=2
			echo "YOU REQUESTED THE GPG FILE DECRYPTION SERVICE"
			get_required_service_type
			;;

	3)		# generate gpg public-key encryption key-pair and manage keys, keyrings and certificates:
			# backup public keyring
			# generate revocation certificate
			# encrypt and backup revocation certificate
			# backup exported exported public key
			service_index=3
			echo "YOU REQUESTED THE GPG PUBLIC KEY AND REVOCATION CERTIFICATE BACKUP SERVICE" && echo
			
			# NOW WE MUST CHECK FOR PRE-REQUISITES:
			# does ...?
			# ...

			generate_gpg_key_pair
			
			;;

	4)		# import GPG public key and backup keyring:
			service_index=4
			echo "YOU REQUESTED THE GPG PUBLIC KEY IMPORT AND KEYRING BACKUP SERVICE"
			get_required_service_type
			;;

	5)		# gpg document encryption and signing  ... for now, return to get_required_service_type and go loopy:
			service_index=5
			echo "YOU REQUESTED THE GPG DOCUMENT ENCRYPTION AND SIGNING SERVICE"
			get_required_service_type
			;;

	9)		echo "NO CURRENT USE - JUST ISSUE THE COMMAND IN A SHELL!"
			service_index=9
			get_required_service_type
			;;

[Qq])		echo
			echo "Goodbye!" && sleep 1
			exit 0
			;;

			# DEFAULT (FAILSAFE) CASE:
	*) 		echo "Just a simple 1-5 will do..." && sleep 2
			service_index=0
		 	get_required_service_type
		 	;;
esac 



	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################
function get_required_service_type
{
##
	echo
	echo ">>>   Which encryption type services do you require...?   :::"
	echo
	echo 
	echo ">>>   1 = GPG encryption of one or more plaintext files"
	echo 
	echo ">>>   2 = GPG decryption of one or more encrypted files"
	echo
	echo ">>>   3 = generate GPG public key encryption key-pair and manage keys and certificates"
	echo
	echo ">>>   4 = import GPG public key and backup keyring"
	echo
	echo ">>>   5 = GPG encryption and signing one or more documents"
	echo
	echo ">>>   [Q/q] = quit, leave, return contRol and exeet"
	echo

	read service_option

	call_service $service_option

}

#######################################################################
# SET PATH TO CONFIGURATION FILE:
## TODO: USE OPTION MENU, THE $REPLY VARIABLE... FOR BETTER INTERACTION
function get_config_file_to_use
{
	## 
	echo
	echo ">>>   Firstly, which configuration file will we be using today...?   :::"
	echo
	echo "Enter the full, absolute path (with leading /), or just press Enter to accept the default"
	echo
	echo 

	read user_config_file_fullpath
}

###############################################################################################
###############################################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'MAIN SECTION'"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

###############################################################################################
# CODE THAT ALWAYS RUNS WHEN SCRIPT IS CALLED:
###############################################################################################

# 1. DETERMINE HOW MANY ARGUMENTS HAVE BEEN PASSED INTO THIS SCRIPT
number_of_incoming_params=$#

echo "Number of arguments passed in = $number_of_incoming_params"

# 2. VERIFY NUMBER OF PARAMS (MUST BE FILE PATHS) && 3. TEST THAT INCOMING STRINGS ARE ALL VALID AND ACCESSIBLE FILE PATHS:

# put the incoming data into an array 
if [ $number_of_incoming_params -gt 0 ]
then
	incoming_array=( "$@" )

	# temporary debug check
	for incoming_string in "${incoming_array[@]}"
	do
		echo "$incoming_string"
	done

	for incoming_string in "${incoming_array[@]}"
	do
		echo "incoming string is now: $incoming_string"
		test_file_path_valid_form "$incoming_string"
		if [ $? -eq 0 ]
		then
			# from now on, we can talk about a plaintext file path...
			plaintext_file_fullpath="$incoming_string"
			echo "The full path to the plaintext file is: $plaintext_file_fullpath"

			## ASSUMING THE FILE IS NOT 'SOMEHOW' SITTING IN THE ROOT DIRECTORY
			plaintext_dir_fullpath=${plaintext_file_fullpath%/*}
			#plaintext_dir_fullpath=$(echo $plaintext_file_fullpath | sed 's/\/[^\/]*$//') ## also works
			echo "The full path to the plaintext file holding directory is: $plaintext_dir_fullpath"
		else
			echo "The valid form test FAILED and returned: $?"
			echo "Nothing to do now, but to exit..." && echo
			exit $E_UNEXPECTED_ARG_VALUE
		fi	

		# if the above test returns ok, plaintext_file_fullpath and plaintext_dir_fullpath are now set
		test_file_path_access "$plaintext_file_fullpath" "$plaintext_dir_fullpath"
		if [ $? -eq 0 ]
		then
			echo "The full path to the plaintext file holding directory is: $plaintext_dir_fullpath"
		else
			echo "The file path access test FAILED and returned: $?"
			echo "Nothing to do now, but to exit..." && echo
			exit $E_REQUIRED_FILE_NOT_FOUND
		fi	

	done

fi

# 3. GET WHICH CONFIGURATION FILE SCRIPT WILL READ FROM AND TEST THAT IT CAN BE ACCESSED AND READ OK

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'SET PATH TO CONFIGURATION FILE' PHASE"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

get_config_file_to_use

config_file_fullpath=${user_config_file_fullpath:-"default_config_file"}

if [ "$config_file_fullpath" == "default_config_file" ]
then
	config_file_name="encryption_services_config"
	echo "Our configuration filename is set to: $config_file_name" && echo

	#config_dir_fullpath="$(cd $script_dir_fullpath; cd ../; pwd)" ## returns with no trailing /
	config_dir_fullpath="/etc"
	echo "PROVISIONALLY:Our configuration file sits in: $config_dir_fullpath" && echo

	config_file_fullpath="${config_dir_fullpath}/${config_file_name}"
	echo "PROVISIONALLY:The full path to our configuration file is: $config_file_fullpath" && echo

elif [ "$config_file_fullpath" == "$user_config_file_fullpath" ]
then
	config_dir_fullpath="${user_config_file_fullpath%'/'*}" # also, try [[:alphanum:]] or [A-Za-z0-9_-]
	echo "PROVISIONALLY:Our configuration file sits in: $config_dir_fullpath" && echo

	config_file_fullpath="$user_config_file_fullpath"
	echo "PROVISIONALLY:The full path to our configuration file is: $config_file_fullpath" && echo
	#exit 0

else
	echo "path to configuration file set to: $config_file_fullpath so I QUIT"
	echo "failsafe exit. Unable to set up a configuration file" && sleep 2
	echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
	exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED

fi

# WHICHEVER WAY THE CONFIG FILE WAS JUST SET, WE NOW TEST ITS' VALIDITY:

test_file_path_valid_form "$config_file_fullpath"
if [ $? -eq 0 ]
then
	echo "Configuration file full path is of VALID FORM"
else
	echo "The valid form test FAILED and returned: $?"
	echo "Nothing to do now, but to exit..." && echo
	exit $E_UNEXPECTED_ARG_VALUE
fi	

# if the above test returns ok, ...
test_file_path_access "$config_file_fullpath" "$config_dir_fullpath"
if [ $? -eq 0 ]
then
	echo "The full path to the CONFIGURATION FILE holding directory is: $config_dir_fullpath"
else
	echo "The CONFIGURATION file path access test FAILED and returned: $?"
	echo "Nothing to do now, but to exit..." && echo
	exit $E_REQUIRED_FILE_NOT_FOUND
fi	

# 4. CHECK THE STATE OF THE ENCRYPTION ENVIRONMENT:
# 
check_encryption_platform

# issue gpg commands to list keys for now... just to see what's there
bash -c "gpg --list-key"
bash -c "gpg --list-secret-keys"

# 0. FIND OUT WHICH SERVICE IS REQUIRED

get_required_service_type

###############################################################################################







###############################################################################################


# 7. ON RETURN OF CONTROL, CHECK FOR DESIRED POSTCONDITIONS


echo "encryption_services exit code: $?" && exit 



# TODO:
# CREATE AND PUSH FLOWCHART ALGORITHM FOR COMMAND GENERATION FUNCTIONS (AN IGNORE FILE)
# CREATE CONFIGURATION IMPORT FUNCTIONS
# CALL SEPARATE SCRIPT FOR EACH DISTINCT SERVICE
# CREATE THE PUBLIC-KEY BACKUP FUNCTIONALITY SCRIPT

# UPDATE THE README.md TO ADD A PRE-REQUISITES SECTION

# UPDATE TO USE OF OPTION SELECTION FUNCTION IF APPROPRIATE


# .. don't forget to unset when returning to calling program

###############################################################################################

## USE CASE - CALLED BY audit_list_maker TO GPG ENCRYPT A SINGLE FILE

# FOR ENCRYPTION OF A SINGLE FILE, ALL es EVER NEEDS TO BE PASSED AS A PARAMETER IS THE ABSOLUTE PATH FILENAME OF THE 
# PLAINTEXT FILE. IT CAN GET EVERYTHING ELSE IT NEEDS EITHER FROM CONFIGURATION FILE DEFAULTS, OR FROM THE USER.
#

# decides whether being called directly or by another script

# takes in, validates and assigns the plaintext filename parameter

# tests its environment - config files, `which gpg`, public key-pair pre-generated...


# gets  and validates any unknown required parameters from the user - sender, recipient UID (based on `hostname`) \
#  if using public key encryption - ANY DEFAULTS FOR THIS COULD BE IN A CONFIGURATION FILE FOR THIS PROGRAM
	# - cryptographic system to be used (whether public key or symmetric key crypto)
	# - the output format whether the binary default for gpg or ascii armoured
	# - the desired output filename for the encrypted file (full path): [DEFAULT = SAME AS INPUT WITH .asc|.pgp]

# if all good, es shows user the command it wants to execute
# $ gpg --armor --output "$plaintext_file_fullpath.asc" --local-user <uid> recipient <uid> --encrypt "$plaintext_file_fullpath"

# if user give ok, es executes the command(s)

# es tests resulting postconditions#

# es reports success to user and returns control

###############################################################################################


#ssh hostname ## this command likely to be read in from file

## definitely control the hosts on which this program can run
#
# hostname will determine which ssh code runs
#

###############################################################################################

# these files need to be backed up and encrypted:
#public keyrings such as:
#~/.gnupg/pubring.gpg 
#~/.gnupg/pubring.kbx
#
#these revocation certs need to be CIA stored, so backup and encryption as well as on separate media
#~/.gnupg/opengpg_revocs.d/
#
#integration with existing system may look like:
#- an option to run this script post-shred an pre-mutables synchronisation

###############################################################################################

# tests whether parameter in of type array, if true returns 0, else returns 1
# declare -a ## returns list of all the current array variables
# grepping with our array works, but not 100% clear on mechanism...	
# TODO: TURN THIS INTO A GENERAL PURPOSE type_array_test FUNCTION IF IT IS NEEDED AGAIN
#declare -a | grep "${incoming_parameter}" 2> /dev/null ##
#if [ $? -eq 0 ]
#then
#	echo "THE INCOMING PARAMETER WAS OF TYPE ARRAY"
#	incoming_array=("${incoming_parameter[@]}")
#else
#	echo "The incoming parameter was NOT of type ARRAY"
#fi
#
#echo ${incoming_parameter[@]}
#
## test whether incoming parameter is of type string
#
#
#
#for ((index=0; index<$number_of_incoming_params; index++));
#	do	
#		position=$((index + 1))
#		echo "position is set to: $position"
#		incoming_array[$index]=${postition}
#	done
