#!/bin/bash
#: Title		:encryption_services
#: Date			:2019-07-13
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:script provides encryption services both to other scripts  
#: Description	:and to the command-line user.  
#: Description	:to encrypt on or more files.
#: Description	:to backup configurations, revocation certs and keys in appropriate ways
#: Description	:integrate with existing system of backup, synchronisation and encryption 
#: Description	:ssh into remotes to backup their keys too
#: Options		:
##
echo "USAGE: $(basename $0) <PROD|DEV>" 
## at command line:~# 
##
#######################################################################

## REMEMBER TO CREATE A GOOD SYSTEM OF VARIABLE SEMANTICS BEFORE
# STARTING TO ASSIGN NAMES. AVOID ON-THE-FLY NAMING. 

#######################################################################

# if we're located outide an executable PATH directory, (eg in a git tracked project directory)
# soft link from PATH directory located namesake
# ln -s TARGET LINK

#######################################################################

# the parent process - so we set any environment variables here.
## AND REMEMBER TO SANITISE CODE

#######################################################################


## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################

# TEST COMMAND LINE ARGS
if [ $# -ne 1 ]
then
	echo "Incorrect number of command line args. Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_INCORRECT_NUMBER_OF_ARGS
fi

# if ! [[ "${1}" = 'DEV' -o "${1}" = 'PROD' ]]
if ! [[ "${1}" = 'DEV' || "${1}" = 'PROD' ]] 
then
	echo "Incorrect command line arg.  Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_UNEXPECTED_ARG_VALUE
fi

#################################

# SET PROGRAM RUN MODE:
# passed in from command line, this is set to:
# DEV when running in non-kali test/development environment
# PROD when running in kali live/production environment
RUN_MODE=$1 
export RUN_MODE

#################################

# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF

# NOTE: if soft-linked from an executables PATH directory, this gives the path to the link
echo "The absolute path to this script is: $0"

## remove from end of full path to script: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"  
echo "Script root directory set to: $script_root_dir"
export script_root_dir

# GLOBAL VARIABLE DECLARATIONS:


function dummy
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

dummy

requested_mount_dir=${1:-"not_yet_set"} ## whether this script run directly or called by shred_dirs
# might also be useful to validate that no parameters were given from the command line.

echo "	==================================================================="
echo "	||                Welcome to ENCRYPTION SERVICES                   ||  author: Damola Adebayo"  
echo "	==================================================================="
echo
echo " Type q to quit."
echo && sleep 2




#########################################################################################################
function read_fs_to_mount()
{
## !!!!!!!! remove all [REFERENCES TO ENCRYPTION PURPOSES] before publishing these scripts - although,
## this is useful reference information at mount-time. hmmm? 
echo
echo ">>>   Which ecrypfs filesystem would you like to mount...?   :::"
echo
## USE THIS DIRECTORY FOR:
## - files that need to be backed up to separate media \
## - AND that must never leave the trusted network due to CIA \
## - AND that must be available for comparison if in any doubt \
## - AND that...
## password db, revoc certs, 
echo ">>>   1 = Maxtor ext HDD research/ [USE FOR CLEAR TEXT PASSWORD DB]"
## This one gets sent over the internet:
echo ">>>   2 = Maxtor ext HDD secure/ [USE FOR ENCRYPTED MUTABLE FILES READY TO CLOUD TRANSFER]"
echo ">>>   3 = Maxtor ext HDD filesystem root, mountpoint: /media/damola/2TB_ext_hdd [NO CURRENT USE]" ## remove this option
echo
echo "======================================================"
echo
echo ">>>   4 = E530c dev/sda1 partition, research/ [USE FOR KEYFILE]"
echo ">>>   5 = E530c dev/sda1 partition, secure/ [USE FOR KEYFILE SOURCE]"
echo ">>>   6 = E530c dev/sda1 partition root, mountpoint: $HOME/Case [NO CURRENT USE]" ## remove this option completely
echo
echo "======================================================"
echo
echo ">>>   7 = E6520 dev/sda5 partition, $HOME/research/ [USE TO BE DETERMINED]"
echo ">>>   8 = E6520 dev/sda5 partition, $HOME/secure/ [USE FOR KEYFILE AND KEYFILE SOURCE]"
echo
echo "======================================================"
echo
echo ">>>   9 = 5490 dev/sda5 partition, $HOME/research/ [USE TO BE DETERMINED]"
echo ">>>   10 = 5490 dev/sda5 partition, $HOME/secure/ [USE FOR KEYFILE ONLY]"
echo
echo "======================================================"
echo

read file_system

do_mounts $file_system

}

###############################################################################################
# if requested_mount_dir is set (don't forget to unset when returning to calling program),
# use it to get file_system from mount_options_lookup_table, not read. change file_system to mount_option_index
function query_fs_to_mount()
{
dir_to_mount=$1

for k in "${!mount_options_lookup_table[@]}"
do
	echo "key  : $k"
	echo "value: ${mount_options_lookup_table[$k]}" && echo
	if [ "$k" == "$dir_to_mount" ]
	then
		file_system="${mount_options_lookup_table[$k]}"
		echo "mount option index FOUND: $file_system" && echo
		break
	fi
done

#exit 0

do_mounts $file_system

}

###############################################################################################




case $requested_mount_dir in
	"not_yet_set")	read_fs_to_mount ## 
									;;
	*) 		echo "requested directory passed into mount_ecrypt_dirs ok" && sleep 1 && echo
				echo "requested directory is $requested_mount_dir" && sleep 1 && echo

				query_fs_to_mount "$requested_mount_dir"
				;;
esac 

#unset $requested_mount_dir




## USE CASE - CALLED BY audit_list_maker TO GPG ENCRYPT A SINGLE FILE
#
# decides whether being called directly or by another script
# takes in and assigns the parameters
# tests for some preconditions:
# - tests its environment - config files, `which gpg`, 
# - test the validity of the provided parameters
# if all good, es shows user the command it wants to execute
# if user give ok, es executes the command(s)
# es tests resulting postconditions
# es reports


#############################################################################

# TEST FOR PRECONDITIONS

#############################################################################


# 
#
#
#
#




#############################################################################

# TEST FOR POSTCONDITIONS

#############################################################################

#ssh hostname ## this command likely to be read in from file

## definitely control the hosts on which this program can run
#
# hostname will determine which ssh code runs
#
# these files need to be backed up and encrypted:
#public keyrings such as:
#~/.gnupg/pubring.gpg 
#~/.gnupg/pubring.kbx
#
#these revocation certs need to be CIA stored, so backup and encryption as well as on separate media
#~/.gnupg/opengpg_revocs.d/
#
#integration with existing system may look like:
#- an option to run this script post-shred an pre-mutables synchronisation
