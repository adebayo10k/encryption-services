#!/bin/bash
#: Title		:encryption_services
#: Date			:2019-07-13
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:script provides encryption services both to other scripts  
#: Description	:and to the command-line user.  
#: Description	:to encrypt on or more files.
#: Description	:to backup configurations, revocation certs and keys in appropriate ways
#: Description	:integrate with existing system of backup, synchronisation and encryption 
#: Description	:ssh into remotes to backup their keys too
#: Options		:
##
echo "USAGE: $(basename $0) <plaintext_file>" 
## at command line:~# 
##
#######################################################################

## REMEMBER TO CREATE A GOOD SYSTEM OF VARIABLE SEMANTICS BEFORE
# STARTING TO ASSIGN NAMES. AVOID ON-THE-FLY NAMING. 

#######################################################################

# if we're located outide an executable PATH directory, (eg in a git tracked project directory)
# soft link from PATH directory located namesake
# ln -s TARGET LINK

#######################################################################

# the parent process - so we set any environment variables here.
## AND REMEMBER TO SANITISE CODE

#######################################################################


## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################


# GLOBAL VARIABLE DECLARATIONS:

plaintext_file_fullpath=""
plaintext_dir_fullpath=""
abs_filepath_regex='^(/{1}[A-Za-z0-9\._-~]+)+$' # absolute file path, ASSUMING NOT HIDDEN FILE, ...
all_filepath_regex='^(/?[A-Za-z0-9\._-~]+)+$' # both relative and absolute file path


echo "	==================================================================="
echo "	||                Welcome to ENCRYPTION SERVICES                   ||  author: adebayo10k"  
echo "	==================================================================="
echo
echo " Type q to quit."
echo && #sleep 2

###############################################################################################


# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF

# NOTE: if soft-linked from an executables PATH directory, this gives the path to the link
echo "The absolute path to this script is: $0"

## TODO: UNLESS SCRIPT 'SOMEHOW' SITS IN THE ROOT DIRECTORY, IN WHICH CASE WE'D JUST REMOVE "$(basename $0)"
## remove from end of full path to script: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"  
echo "Script root directory set to: $script_root_dir"
export script_root_dir


echo "ON ENTRY, script_root_dir WAS SET TO: $script_root_dir"
echo "YOUR CURRENT SHELL LEVEL IS: $SHLVL"

read

incoming_parameter=${1:-"not_yet_set"} ## whether this script run directly from command-line or called by another script
# might also be useful to validate that no parameters were given from the command line.


###############################################################################################
#########################################################################################################
function dummy
{
	service_option="$1"
	
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "user has selected option: $service_option"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################
function get_service_type
{
##
	echo
	echo ">>>   Which encryption type services do you require...?   :::"
	echo
	### 
	echo ">>>   1 = gpg encryption of one or more plaintext files"
	## 
	echo ">>>   2 = gpg decryption of one or more encrypted files"
	echo ">>>   3 = backup of keys and certs to synch'd location"
	echo

	read service_option

	dummy $service_option

}

###############################################################################################
###############################################################################################

# firstly, we test that the parameter we got is of the correct form for an absolute file path 
# 
# 
function test_file_path_valid_form
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	
	echo "test_file_fullpath is set to: $test_file_fullpath"
	#echo "test_dir_fullpath is set to: $test_dir_fullpath"

	if [[ $test_file_fullpath =~ $abs_filepath_regex ]]
	then
		echo "THE FORM OF THE INCOMING PARAMETER IS THEREFORE OF A VALID ABSOLUTE FILE PATH"
		plaintext_file_fullpath="$test_file_fullpath"
		echo "The full path to the plaintext file is: $plaintext_file_fullpath"

		## ASSUMING THE FILE IS NOT 'SOMEHOW' SITTING IN THE ROOT DIRECTORY
		plaintext_dir_fullpath=${plaintext_file_fullpath%/*}
		#plaintext_dir_fullpath=$(echo $plaintext_file_fullpath | sed 's/\/[^\/]*$//')
		echo "The full path to the plaintext file holding directory is: $plaintext_dir_fullpath"
	else
		echo "AN INCOMING PARAMETER WAS SET, BUT WAS NOT A MATCH FOR OUR KNOWN PATH FORM REGEX "$abs_filepath_regex"" && sleep 1 && echo
		echo "Exiting..."
		exit $E_UNEXPECTED_ARG_VALUE
	fi 


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}



###############################################################################################
# need to test for read access to file 
# need to test for access to the file holding directory
# 
function test_file_path_access
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	test_dir_fullpath=$2

	echo "test_file_fullpath is set to: $test_file_fullpath"
	echo "test_dir_fullpath is set to: $test_dir_fullpath"



	if [ -d "$test_dir_fullpath" ] && cd "$test_dir_fullpath" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir_fullpath" found and accessed ok" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi

	# test for expected file type (regular) and read permission
	if [ -f "$test_file_fullpath" ] && [ -r "$test_file_fullpath" ]
	then
		# plaintext file found and accessible
		echo "Plaintext file found to be readable" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
###############################################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'MAIN SECTION'"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo


case $incoming_parameter in
	"not_yet_set")			get_service_type ## 
							;;

				*)			echo "plaintext file path (absolute) offered as: "$incoming_parameter""
							echo "regular expression set to: "$abs_filepath_regex"" && sleep 1 && echo

							#create and test preconditions
							test_file_path_valid_form "$incoming_parameter"					
							test_file_path_access "$plaintext_file_fullpath" "$plaintext_dir_fullpath"

							#exit 0

							#test_environment
							#get_encryption_parameters # from user

							# meat
							#create_command

							# test postconditions

							;;
esac 




# if ... don't forget to unset when returning to calling program),



## USE CASE - CALLED BY audit_list_maker TO GPG ENCRYPT A SINGLE FILE

# FOR ENCRYPTION OF A SINGLE FILE, ALL es EVER NEEDS TO BE PASSED AS A PARAMETER IS THE ABSOLUTE PATH FILENAME OF THE 
# PLAINTEXT FILE. IT CAN GET EVERYTHING ELSE IT NEEDS EITHER FROM CONFIGURATION FILE DEFAULTS, OR FROM THE USER.
#

# decides whether being called directly or by another script

# takes in, validates and assigns the plaintext filename parameter

# tests its environment - config files, `which gpg`, public key-pair pre-generated...


# gets  and validates any unknown required parameters from the user - sender, recipient UID (based on `hostname`) \
#  if using public key encryption - ANY DEFAULTS FOR THIS COULD BE IN A CONFIGURATION FILE FOR THIS PROGRAM
	# - cryptographic system to be used (whether public key or symmetric key crypto)
	# - the output format whether the binary default for gpg or ascii armoured
	# - the desired output filename for the encrypted file (full path): [DEFAULT = SAME AS INPUT WITH .asc|.pgp]

# if all good, es shows user the command it wants to execute

# if user give ok, es executes the command(s)

# es tests resulting postconditions#

# es reports success to user and returns control




#ssh hostname ## this command likely to be read in from file

## definitely control the hosts on which this program can run
#
# hostname will determine which ssh code runs
#
# these files need to be backed up and encrypted:
#public keyrings such as:
#~/.gnupg/pubring.gpg 
#~/.gnupg/pubring.kbx
#
#these revocation certs need to be CIA stored, so backup and encryption as well as on separate media
#~/.gnupg/opengpg_revocs.d/
#
#integration with existing system may look like:
#- an option to run this script post-shred an pre-mutables synchronisation
