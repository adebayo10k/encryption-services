#!/bin/bash
#: Title		:encryption_services
#: Date			:2019-07-13
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:script provides encryption services both to other scripts  
#: Description	:and to the command-line user.  
#: Description	:to encrypt on or more files.
#: Description	:to backup configurations, revocation certs and keys in appropriate ways
#: Description	:integrate with existing system of backup, synchronisation and encryption 
#: Description	:ssh into remotes to backup their keys too
#: Options		:
##
echo "USAGE: $(basename $0) <file paths>" # zero or more strings (representing fullpaths to files)
## at command line:~# 
##
#######################################################################

## REMEMBER TO CREATE A GOOD SYSTEM OF VARIABLE SEMANTICS BEFORE
# STARTING TO ASSIGN NAMES. AVOID ON-THE-FLY NAMING. 

#######################################################################

# if we're located outide an executable PATH directory, (eg in a git tracked project directory)
# soft link from PATH directory located namesake
# ln -s TARGET LINK

#######################################################################

# the parent process - so we set any environment variables here.
## AND REMEMBER TO SANITISE CODE

#######################################################################


## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_REQUIRED_PROGRAM_NOT_FOUND=21
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_REQUIRED_PROGRAM_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################


# GLOBAL VARIABLE DECLARATIONS:

declare -a incoming_array=()
#incoming_string=""

encryption_system= # public_key | symmetric_key
output_file_format= # ascii | binary
sender_uid=""
recipient_uid=""
declare -a recipient_uid_list=()

generic_command=""
file_specific_command=""

gpg_command='gpg'
armor_option='--armor'
output_option='--output'
#ascii_file_extension='.asc' #default
#binary_file_extension='.gpg'
output_file_extension= # .asc | .gpg
sender_option='--local-user'
recipient_option='--recipient'
#public_key_encrypt_option='--encrypt'
#symmetric_encrypt_option='--symmetric'
encryption_system_option= # --encrypt | --symmetric
file_path_placeholder='<filepath_placeholder>'



plaintext_file_fullpath=""
plaintext_dir_fullpath=""
abs_filepath_regex='^(/{1}[A-Za-z0-9\._-~]+)+$' # absolute file path, ASSUMING NOT HIDDEN FILE, ...
all_filepath_regex='^(/?[A-Za-z0-9\._-~]+)+$' # both relative and absolute file path


echo "	==================================================================="
echo "	||                Welcome to ENCRYPTION SERVICES                   ||  author: adebayo10k"  
echo "	==================================================================="
echo
echo " Type q to quit."
echo && #sleep 2

###############################################################################################


# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF

# NOTE: if soft-linked from an executables PATH directory, this gives the path to the link
echo "The absolute path to this script is: $0"

## TODO: UNLESS SCRIPT 'SOMEHOW' SITS IN THE ROOT DIRECTORY, IN WHICH CASE WE'D JUST REMOVE "$(basename $0)"
## remove from end of full path to script: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"  
echo "Script root directory set to: $script_root_dir"
export script_root_dir


echo "ON ENTRY, script_root_dir WAS SET TO: $script_root_dir"
echo "YOUR CURRENT SHELL LEVEL IS: $SHLVL"

read

###############################################################################################
# need to test for read access to file 
# need to test for encrypted file type
# 
function verify_file_encryption_results
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	valid_path="$1"


	result=$(file "${valid_path}$output_file_extension" | grep 'PGP') # &2>/dev/null)

	if [ $? -eq 0 ] && [ "$encryption_system" == "public_key" ]
	#if [ $result -eq 0 ]
	then
		echo "PUBLIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
		echo "${valid_path}$output_file_extension"
	elif [ $? -eq 0 ] && [ "$encryption_system" == "symmetric_key" ]
	then
		echo "SYMMETRIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
		echo "${valid_path}$output_file_extension"
	else
		return 1 ## unexpected file type
	fi



	#if [ "$encryption_system" == "public_key" ]
	#then
	#	result=$(file "${valid_path}$output_file_extension" | grep 'PGP') # &2>/dev/null)
	#	if [ $? -eq 0 ]
	#	#if [ $result -eq 0 ]
	#	then
	#		echo "PUBLIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
	#		echo "${valid_path}$output_file_extension"
	#	else
	#		return 1 ## unexpected file type
	#	fi
#
#
	#elif [ encryption_system == "symmetric_key" ]
	#then
	#	result=$(file "${valid_path}$output_file_extension" | grep 'PGP') # &2>/dev/null
	#	if [ $? -eq 0 ]
	#	then
	#		echo "SYMMETRIC KEY ENCRYPTED FILE CREATED SUCCESSFULLY AS:"
	#		echo "${valid_path}$output_file_extension"
	#	else
	#		return 1 ## unexpected file type
	#	fi
#
#
	#else
	#	echo "FAILSAFE BRANCH ENTERED UNEXPECTEDLY"
	#	return $E_UNEXPECTED_BRANCH_ENTERED
	#fi
	
	# test for expected file type (regular) and read permission
	if [ -f "${valid_path}$output_file_extension" ]  && [ -r "${valid_path}$output_file_extension" ]
	then
		# plaintext file found and accessible
		echo "Plaintext file found to be readable" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Returning from function ${FUNCNAME[0]} in script $(basename $0)"
		return $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

	return 0
}

###############################################################################################
# the absolute path to the plaintext file is passed in
#
function execute_file_specific_encryption_command
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	valid_path="$1"

	# using [,] delimiter to avoid interference with [/]
	file_specific_command=$(echo "$generic_command" | sed 's,'$file_path_placeholder','$valid_path',' | sed 's,'$file_path_placeholder','$valid_path',')

	echo "$file_specific_command"

	# get user confirmation before executing file_specific_command
	# [call a function for this, which can abort the whole encryption process if there's a problem at this point]
	echo "command look ok?"
	read	# just pause here for now

	# execute file_specific_command if return code from user confirmation = 0
	# execute [here] using bash -c ...
	bash -c "$file_specific_command"


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
# this function called if encryption_system="symmetric"
function create_generic_symmetric_key_encryption_command_string
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "OK, WE'RE HERE, READY TO BUILD THAT COMMAND STRING"

# $ gpg --armor --output "$plaintext_file_fullpath.asc" --symmetric "$plaintext_file_fullpath"

	generic_command=

	generic_command+="${gpg_command} "

	if [ $output_file_format == "ascii" ]
	then
		generic_command+="${armor_option} "
		generic_command+="${output_option} ${file_path_placeholder}"
		generic_command+="${output_file_extension} "
	fi

	generic_command+="${encryption_system_option} ${file_path_placeholder}"


	echo "$generic_command"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}
###############################################################################################
# this function called if encryption_system="public_key"
function create_generic_pub_key_encryption_command_string
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "OK, WE'RE HERE, READY TO BUILD THAT COMMAND STRING"

# $ gpg --armor --output "$plaintext_file_fullpath.asc" --local-user <uid> --recipient <uid> --encrypt "$plaintext_file_fullpath"

	generic_command=

	generic_command+="${gpg_command} "

	if [ $output_file_format == "ascii" ]
	then
		generic_command+="${armor_option} "
		generic_command+="${output_option} ${file_path_placeholder}"
		generic_command+="${output_file_extension} "
	fi

	generic_command+="${sender_option} "
	generic_command+="${sender_uid} "

	for recipient in ${recipient_uid_list[@]}
	do
		generic_command+="${recipient_option} ${recipient} "
	done

	generic_command+="${encryption_system_option} ${file_path_placeholder}"

	echo "$generic_command"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}


###############################################################################################

function get_recipient_uid
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	while true
	do

		echo "Enter the user-id of a RECIPIENT || Type exit"
		read uid

		# validate recipient_uid HERE

		recipient_uid="$uid"
		echo "One recipients user-id is now set to the value: $recipient_uid" && echo
		recipient_uid_list+=( "${recipient_uid}" )
		
		echo "Any more recipients (whose public keys we hold) [y/n]?"
		read more_recipients_answer


		case $more_recipients_answer in
		[yY])	echo "OK, another recipient requested...." && echo
				;;
		[nN])	echo "OK, no more recipients needed...." && echo
				break
				;;
		*)		echo "Entered the FAILSAFE BRANCH...." && echo
				echo "Continuing with while loop, as if (y) response...." && echo 
				;;
		esac
	done


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################

function get_sender_uid
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "Enter the user-id of the SENDER || Type q to exit"
	read uid

	# validate sender_uid HERE

	sender_uid="$uid"
	echo "sender user-id is now set to the value: $sender_uid"



	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
#
function set_defaults
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	encryption_system="public_key" #default
	output_file_format="ascii" #default

	if [ $encryption_system == "public_key" ]
	then
		encryption_system_option='--encrypt'
	elif [ $encryption_system == "symmetric_key" ]
	then
		encryption_system_option='--symmetric'
	else
		echo "FAILSAFE BRANCH ENTERED"
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED
	fi

	if [ $output_file_format == "ascii" ]
	then
		output_file_extension=".asc" #default
	elif [ $output_file_format == "binary" ]
	then
		output_file_extension=".gpg"
	else
		echo "FAILSAFE BRANCH ENTERED"
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED
	fi	


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################
###############################################################################################
###############################################################################################
# 
function get_config_mode
{
		echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	## reset variables:
	mode_answer=""
	
	echo ">>>   Use defaults or configure parameters...?   :::"
	echo
	echo "Defaults mode = 2"
	echo "Config mode = 9"
	echo

	read mode_answer
	case $mode_answer in 
		[2])	set_defaults ## set all the defaults by importing them from a configuration file
								# or for now, just assigning the values
				echo "DEFAULT VALUES FOR COMMAND GENERATION HAVE NOW BEEN SET"
				#
				return 2
					;;
		[9]) 	echo "IN FUTURE, WE'LL GET USER PROVIDED CONFIGURATION PARAMETERS."
				echo "... BUT FOR NOW, ONLY DEFAULTS MODE IS AVAILABLE."
				get_config_mode
				# return 9
					;;
		*) 		echo "Just one of two numbers... a 1 or a 7..." && sleep 1
				get_config_mode
					;;
	esac 

	echo
	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

########################################################################################## 
###############################################################################################
###############################################################################################
# list the keys available on the system
# get the users' gpg user-id 
# test that valid, ultimate trust fingerprint exists for that user-id
function check_gpg_user_keys
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	userid=""

	# issue gpg commands to list keys for now... just as a prompt of user-id details
	bash -c "gpg --list-key"
	bash -c "gpg --list-secret-keys"

	# get the users' gpg UID from terminal
	echo "Please enter your user-id (example: smoothcoder@sharkpool.org)"

	read userid

	# now check for a key-pair fingerprint. TODO: if not found, user should have the opportunity to try again
	# TODO: THIS IS NOT THE RIGHT TEST, FIND SOMETHING BETTER LATER
	bash -c "gpg --fingerprint "$userid" 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "KEY-PAIR FINGERPRINT IDENTIFIED FOR USER-ID OK"
	else
		echo "FAILED TO FIND THE KEY-PAIR FINGERPRINT FOR THAT USER-ID"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi



	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

###############################################################################################

# check that the OpenPGP tool gpg is installed on the system
#  
function check_encryption_platform
{
		
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	bash -c "which gpg 2>/dev/null" # suppress stderr (but not stdout for now)
	if [ $? -eq 0 ]
	then
		echo "OpenPGP PROGRAM INSTALLED ON THIS SYSTEM OK"
	else
		echo "FAILED TO FIND THE REQUIRED OpenPGP PROGRAM"
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_PROGRAM_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################

###############################################################################################

# firstly, we test that the parameter we got is of the correct form for an absolute file path 
# 
# 
function test_file_path_valid_form
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	
	echo "test_file_fullpath is set to: $test_file_fullpath"
	#echo "test_dir_fullpath is set to: $test_dir_fullpath"

	if [[ $test_file_fullpath =~ $abs_filepath_regex ]]
	then
		echo "THE FORM OF THE INCOMING PARAMETER IS THEREFORE OF A VALID ABSOLUTE FILE PATH"
		# from now on, we can talk about a plaintext file path...
		plaintext_file_fullpath="$test_file_fullpath"
		echo "The full path to the plaintext file is: $plaintext_file_fullpath"

		## ASSUMING THE FILE IS NOT 'SOMEHOW' SITTING IN THE ROOT DIRECTORY
		plaintext_dir_fullpath=${plaintext_file_fullpath%/*}
		#plaintext_dir_fullpath=$(echo $plaintext_file_fullpath | sed 's/\/[^\/]*$//') ## also works
		echo "The full path to the plaintext file holding directory is: $plaintext_dir_fullpath"
	else
		echo "AN INCOMING PARAMETER WAS SET, BUT WAS NOT A MATCH FOR OUR KNOWN PATH FORM REGEX "$abs_filepath_regex"" && sleep 1 && echo
		echo "Exiting..."
		exit $E_UNEXPECTED_ARG_VALUE
	fi 


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
# need to test for read access to file 
# need to test for access to the file holding directory
# 
function test_file_path_access
{
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo


	test_file_fullpath=$1
	test_dir_fullpath=$2

	echo "test_file_fullpath is set to: $test_file_fullpath"
	echo "test_dir_fullpath is set to: $test_dir_fullpath"


		# && if #2 is set
	if [ -d "$test_dir_fullpath" ] && cd "$test_dir_fullpath" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir_fullpath" found and accessed ok" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi

	# test for expected file type (regular) and read permission
	if [ -f "$test_file_fullpath" ] && [ -r "$test_file_fullpath" ]
	then
		# plaintext file found and accessible
		echo "Plaintext file found to be readable" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi


	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo
}

###############################################################################################
#########################################################################################################
## SET GLOBAL VARIABLES REGARDING SPECIFIC SERVICE
function dummy
{
	service_option="$1"
	
	echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	echo "user has selected option: $service_option"

	echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#########################################################################################################
function get_required_service_type
{
##
	echo
	echo ">>>   Which encryption type services do you require...?   :::"
	echo
	### 
	echo ">>>   1 = gpg encryption of one or more plaintext files"
	## 
	echo ">>>   2 = gpg decryption of one or more encrypted files"
	echo ">>>   3 = backup of keys and certs to synch'd location"
	echo
	echo ">>>   9 = quit, leave, return contol and exeet"
	echo
	read service_option

	dummy $service_option

}

###############################################################################################
###############################################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'MAIN SECTION'"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

# #########

# NEW STRATEGY:

# 0. FIND OUT WHICH SERVICE IS REQUIRED

get_required_service_type

# 1. DETERMINE HOW MANY ARGUMENTS HAVE BEEN PASSED INTO THIS SCRIPT
number_of_incoming_params=$#

echo "Number of arguments passed in = $number_of_incoming_params"

# 2. DETERMINE DATA TYPE | DO A FILE PATH VALIDATION TEST | 

# put the incoming data into an array 
if [ $number_of_incoming_params -gt 0 ]
then
	incoming_array=( "$@" )

	# temporary debug check
	for incoming_string in "${incoming_array[@]}"
	do
		echo "$incoming_string"
	done
fi


# 3. TEST THAT INCOMING STRINGS ARE ALL VALID AND ACCESSIBLE FILE PATHS

for incoming_string in "${incoming_array[@]}"
do
	echo "incoming string is now: $incoming_string"
	test_file_path_valid_form "$incoming_string"
	test_file_path_access "$plaintext_file_fullpath" "$plaintext_dir_fullpath"

done

# 4. CHECK THE STATE OF THE ENCRYPTION ENVIRONMENT

# 
check_encryption_platform
# 
check_gpg_user_keys # from user
# 

# 5. BASED ON PREVIOUSLY SELECTED SERVICE OPTION, CALL AN APPROPRIATE SCRIPT (although we'll do stuff here for now)

# sets the generic_command global
#create a generic file encryption command string for either public key or symmetric key encryption:

get_config_mode

if [ $encryption_system = "public_key" ]
then
	echo "encrytion_system is set to public-key, so we now need to request sender and recipient uids"

	get_sender_uid
	echo "sender user-id is now set to the value: $sender_uid"

	get_recipient_uid
	for recipient in ${recipient_uid_list[@]}
	do
		echo "From our array, a recipient is: ${recipient}"
	done

	create_generic_pub_key_encryption_command_string ## make this a public key specific one

else # encryption_system must be symmetric [make this into an elif]
	create_generic_symmetric_key_encryption_command_string ##  make this a symmetric key specific one
fi

#create, then execute each file specific encryption command, then shred plaintext file:
for valid_path in "${incoming_array[@]}"
do
	echo "about to execute on file: $valid_path"
	execute_file_specific_encryption_command "$valid_path" #

	# check that expected output file now exists, is accessible and has expected encypted file properties
	verify_file_encryption_results "${valid_path}"
	if [ $? -ne 0 ]
	then
		echo "FAILURE REPORT...ON STATE..."
		exit 1
	else
		# shred the plaintext file and verify its' removal
		echo "Ok to shred this file?..." && echo
		echo "$valid_path"

		read


		echo
		
	fi
	
	



done


# 6. ON RETURN OF CONTROL, CHECK FOR DESIRED POSTCONDITIONS


exit





#	create_generic_pub_key_encryption_command_string ## make this a public key specific one
#
#else
#	create_generic_symmetric_key_encryption_command_string ##  make this a symmetric key specific one
#fi
#
#for valid_path in "${incoming_array[@]}"
#do
#	echo "about to execute on file: $valid_path"
#	#execute_file_specific_encryption_command "$valid_path" #
#
#done
#
#
## 6. ON RETURN OF CONTROL, CHECK FOR DESIRED POSTCONDITIONS
#
#
#exit





# TODO:
# CREATE AND PUSH FLOWCHART ALGORITHM FOR COMMAND GENERATION FUNCTIONS (AN IGNORE FILE)
# CREATE CONFIGURATION IMPORT FUNCTIONS
# CALL SEPARATE SCRIPT FOR EACH DISTINCT SERVICE
# CREATE A PUBLIC-KEY BACKUP FUNCTIONALITY SCRIPT

# UPDATE THE README.md TO ADD A PRE-REQUISITES SECTION

# UPDATE TO USE OF OPTION SELECTION FUNCTION IF APPROPRIATE



# if ... don't forget to unset when returning to calling program),



## USE CASE - CALLED BY audit_list_maker TO GPG ENCRYPT A SINGLE FILE

# FOR ENCRYPTION OF A SINGLE FILE, ALL es EVER NEEDS TO BE PASSED AS A PARAMETER IS THE ABSOLUTE PATH FILENAME OF THE 
# PLAINTEXT FILE. IT CAN GET EVERYTHING ELSE IT NEEDS EITHER FROM CONFIGURATION FILE DEFAULTS, OR FROM THE USER.
#

# decides whether being called directly or by another script

# takes in, validates and assigns the plaintext filename parameter

# tests its environment - config files, `which gpg`, public key-pair pre-generated...


# gets  and validates any unknown required parameters from the user - sender, recipient UID (based on `hostname`) \
#  if using public key encryption - ANY DEFAULTS FOR THIS COULD BE IN A CONFIGURATION FILE FOR THIS PROGRAM
	# - cryptographic system to be used (whether public key or symmetric key crypto)
	# - the output format whether the binary default for gpg or ascii armoured
	# - the desired output filename for the encrypted file (full path): [DEFAULT = SAME AS INPUT WITH .asc|.pgp]

# if all good, es shows user the command it wants to execute
# $ gpg --armor --output "$plaintext_file_fullpath.asc" --local-user <uid> recipient <uid> --encrypt "$plaintext_file_fullpath"

# if user give ok, es executes the command(s)

# es tests resulting postconditions#

# es reports success to user and returns control




#ssh hostname ## this command likely to be read in from file

## definitely control the hosts on which this program can run
#
# hostname will determine which ssh code runs
#
# these files need to be backed up and encrypted:
#public keyrings such as:
#~/.gnupg/pubring.gpg 
#~/.gnupg/pubring.kbx
#
#these revocation certs need to be CIA stored, so backup and encryption as well as on separate media
#~/.gnupg/opengpg_revocs.d/
#
#integration with existing system may look like:
#- an option to run this script post-shred an pre-mutables synchronisation

#incoming_parameter=${1:-"not_yet_set"} ## whether this script run directly from command-line or called by another script
# might also be useful to validate that no parameters were given from the command line.


#primerArray=("${!1}")

#for generated_hash in "${primerArray[@]}"; do


# tests whether parameter in of type array, if true returns 0, else returns 1
# declare -a ## returns list of all the current array variables
# grepping with our array works, but not 100% clear on mechanism...	
# TODO: TURN THIS INTO A GENERAL PURPOSE type_array_test FUNCTION IF IT IS NEEDED AGAIN
#declare -a | grep "${incoming_parameter}" 2> /dev/null ##
#if [ $? -eq 0 ]
#then
#	echo "THE INCOMING PARAMETER WAS OF TYPE ARRAY"
#	incoming_array=("${incoming_parameter[@]}")
#else
#	echo "The incoming parameter was NOT of type ARRAY"
#fi
#
#echo ${incoming_parameter[@]}
#
## test whether incoming parameter is of type string
#
#
#
#for ((index=0; index<$number_of_incoming_params; index++));
#	do	
#		position=$((index + 1))
#		echo "position is set to: $position"
#		incoming_array[$index]=${postition}
#	done
	#for ((i=0; i<${#b64_index_numbers[@]}; i++));